构建与资源层优化
    关键思路：
        让浏览器少下载、快解析、缓存好、渲染快

优化方向：
    1.构建体积优化 ，  减小打包后的bundle 
        Tree Shaking   、  Code Splitting（代码分割）、 按需引入
    2.缓存与CDN优化 ， 减少重复请求 
        文件哈希、CDN缓存
    3.图片与静态资源优化 ， 提高加载速度
        压缩图片、懒加载、CDN存储、WebP
    4.依赖与构建工具优化 ， 提高构建效率 与性能
        Vite、Webpack、ESBuild、SWC
    5.SSR与Hydration , 首屏性能优化
        服务端渲染（SSR）、客户端 hydration、Next.js 等框架

1、构建体积优化 (构建项目时，体积优化)
    1.1 Tree Shaking
        移除未使用的代码，减小 bundle 体积。
        基于 ES Module 规范，只打包使用到的代码。
        webpack | Vite 都支持 Tree Shaking。

        示例：
            // 未使用的代码
            import { unusedFunction } from './utils';
            
            // 打包后 bundle 体积会包含 unusedFunction 代码
            // 优化后，unusedFunction 代码会被 Tree Shaking 移除


    1.2 Code Splitting  （代码分割）
        动态导入来按需加载代码块。减少初始包体积。
        避免首屏加载所有代码。
        示例：
            // 路由懒加载
            const UserPage = React.lazy(() => import('./UserPage'));
        webpack 自动将每个懒加载模块打成单独 chunk；
        用户访问到该页面时才会加载对应 chunk。
            
    1.3 按需引入组件库 （组件库代码分割）
        只引入必要的模块，减少打包体积。
        很对UI库 Ant Design 、 Material-UI  都是 默认全量引入 ，非常耗性能
        示例：
        // ❌ 全量引入（打包巨大）
        import { Button, Select } from 'antd';

        // ✅ 按需引入（只打包用到的）
        import Button from 'antd/es/button';
        import Select from 'antd/es/select';

        或者使用 babel-plugin-import 插件自动按需引入：

            安装插件：
            npm install babel-plugin-import --save-dev
            配置 .babelrc 或 babel.config.js：
            {
                "plugins": [
                    ["import", { "libraryName": "antd", "style": true }]
                ]
            }

2、缓存与CDN优化 （浏览器缓存 与 内容分发网络）
    2.1 文件哈希（缓存 busting）
        每次构建时，文件名包含哈希值（如 bundle.12345.js）。
        文件名变化导致浏览器重新下载文件，避免使用缓存。
        示例：
            // webpack 配置
            output: {
                filename: '[name].[contenthash].js',
                path: path.resolve(__dirname, 'dist')
            }
    2.2 CDN 缓存
        将静态资源（如图片、字体）部署到 CDN 上。
        用户请求资源时，从离用户最近的 CDN 节点获取，减少延迟。
        示例：
            // 图片 CDN 配置
            <img src="https://cdn.example.com/image.jpg" alt="example" />

3.图片与静态资源优化 （图片压缩、懒加载、CDN存储、WebP）
    图片是影响性能最大的因素之一
    图片优化手段：
        压缩图片（如使用 TinyPNG、Compressor.io）
        懒加载图片（如使用 IntersectionObserver）
        CDN 存储图片（如使用 Cloudinary、Imgix）
        使用 WebP 格式图片（浏览器支持度高，体积小）
        响应式图片（根据设备屏幕尺寸加载不同分辨率图片）

4.构建工具层优化 （Vite、Webpack、ESBuild、SWC）
    1.使用Vite或ESBuild
        更快地热更新（HMR）
        更快的构建速度
        更高效的按需模块加载
    Vite 默认使用 ESM 动态导入 + Rollup 打包，在开发和构建阶段性能优于 webpack。
    2.使用Webpack
        更成熟的插件系统
        更丰富的配置选项
        更广泛的社区支持

5.SSR（服务端渲染） 与 Hydration （水合）
    5.1 服务端渲染（SSR）
        服务器端渲染页面，返回完整 HTML 给客户端。
        首次加载快，对 SEO 友好。
        
        使用 Next.js / Remix：
            在服务端渲染 HTML；
            客户端接管后“水合”成可交互页面。

    5.2 客户端 hydration
        客户端接收到 HTML 后，通过 JavaScript 渲染成交互页面。
        后续导航快，用户体验好。
        示例：React、Vue.js
    
6.Gzip与 Brotli 压缩 （压缩传输体积）
        压缩传输的 HTML、CSS、JS 文件，减少网络传输时间。
        示例：Nginx、Apache 配置压缩。
    压缩原理：
        将Js、CSS、HTML 文件压缩成 gzip 或 brotli 格式。
        浏览器收到压缩文件后，自动解压缩。