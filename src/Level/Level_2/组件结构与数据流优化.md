组件结构与数据流优化
    主要关心组件拆分、状态管理和数据流设计
    目的是减少不必要的渲染和提升应用整体性能

1、合理拆封组件
    为什么要拆分组件？
        React默认 父组件更新 -> 子组件也会更新
        如果组件过大或包含大量子组件，每次更新都会触发全树渲染
        拆分组件可以 ****局部更新****  ， 只渲染需要更新的部分
    
    拆分策略
        1、关注单一功能
            1.1 每个组件只处理一个逻辑或界面的部分
            1.2 示例 ： 表单输入组件、按钮组件、列表行组件
        2、状态局部化
            将state放在最小需要的组件内，避免全局state变动导致大量组件更新
        3、避免过度拆分
            不要为了拆分而拆分，每个组件都有其职责和功能
            过度拆分会导致组件之间的通信复杂，增加维护成本
    示例：
        function UserProfile({ user }) {
            return (
                <div>
                <Avatar avatarUrl={user.avatar} />
                <UserInfo info={user.info} />
                </div>
            );
        }

        const Avatar = React.memo(({ avatarUrl }) => <img src={avatarUrl} alt="avatar" />);
        const UserInfo = React.memo(({ info }) => <div>{info.name}</div>);
    
    拆分后，即使 userInfo 更新， Avatar 也不会重新渲染，  本质上还是使用 React.memo 进行了优化

2、状态提升与状态局部化
    状态提升
        将子组件的state提升到父组件共享
        优点：多个子组件可以共享状态
        缺点：父组件每次更新会触发所有子组件重新渲染
    状态局部化
        尽量把state放在最小的组件内
        避免父组件不必要渲染
        示例：
            // 状态提升（父组件更新 → 所有子组件渲染）
            function Counter() {
                const [count, setCount] = useState(0);
                return (
                    <div>
                    <button onClick={() => setCount(count + 1)}>加 1</button>
                    <Child count={count} />
                    <Child2 count={count} />
                    </div>
                );
            }
            const Child = React.memo(({ count }) => <div>当前计数：{count}</div>);
            const Child2 = React.memo(({ count }) => <div>当前计数：{count}</div>);

            上面这个是状态提升的示例，每次点击按钮，所有子组件都会重新渲染
            下面这个是状态局部化的示例，每次点击按钮，只有相关子组件会重新渲染
                const Child1 = () => {
                    const [count, setCount] = useState(0);
                    return <button onClick={() => setCount(count + 1)}>加 1</button>;
                };
                const Child2 = () => <div>我不受 Child1 影响</div>;

3. 使用Context优化全局数据流
    Context的作用
        避免  props 层层传递
        提供全局访问的状态
        用于主题、用户信息、语言、全局状态 等共享信息
    Context的问题
        Context更新会触发消费组件重新渲染
        解决方法：
            1、使用 React.memo 包裹消费组件，避免不必要的渲染 或使用 useContextSelector 只订阅需要的状态
            2、将 Context 拆分成多个小的 Context，每个 Context 只负责管理一个状态
        示例：
            const ThemeContext = React.createContext('light');

            const App = () => {
                const [theme, setTheme] = useState('light');
                const value = useMemo(() => ({ theme, setTheme }), [theme]);

                return (
                    <ThemeContext.Provider value={value}>
                        <Toolbar />
                    </ThemeContext.Provider>
                );
            };

            const Toolbar = () => {
                return <ThemeButton />; // 只用 theme，不用每次都渲染 Toolbar
            };

            const ThemeButton = React.memo(() => {
                const { theme } = useContext(ThemeContext);
                return <button>{theme}</button>;
            });
        
        这里的优化点是：
            1、Toolbar 只渲染一次，不会因为 theme 变化而重新渲染
            2、ThemeButton 只有在 theme 变化时才会重新渲染
        
        通过使用 React.memo 包裹 ThemeButton，只有当 theme 变化时才会重新渲染，避免了不必要的渲染
        并且通过 useMemo 缓存了 { theme, setTheme }，如果没有使用 useMemo，每次渲染都创建新的对象，导致 ThemeButton 每次渲染都重新创建， 也会导致不必要的渲染

4.合理使用 key
    为什么key重要
        React的diff算法以来key
        key不唯一或频繁变化 -> React 会销毁旧节点并创建 新节点 -> 性能浪费
    使用建议
        1.列表渲染必须使用唯一且稳定的key
            {items.map(item => <Item key={item.id} data={item} />)}
        2.避免使用索引作为 key
            数组可变或有增删操作时，索引会导致不必要的重渲染或DOM复用错误

核心思路：
    拆分组件 ->减少不必要的渲染 
    状态局部化-> 只更新必要组件
    Context+key -> 优化全局数据流与diff计算